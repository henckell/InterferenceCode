A.init[16, c(5,15, 25)] = 1
# ZG
A.init[17, c(18,21,11,12)] = 1
# SZ
A.init[18,c(17,14,15,19,20,21,12)] = 1
# GL
A.init[19,c(18,15,25,20)] = 1
# SG
A.init[20, c(25,24,23,26,21,18,19)] = 1
# ZH
A.init[21,c(20,26,22,11,17,18)] = 1
# SH
A.init[22,c(21,26)] = 1
# AR
A.init[23, c(20,24)] = 1
# AI
A.init[24, c(20,23)] = 1
# GR
A.init[25,c(20,19,15,16)] = 1
# TG
A.init[26,c(22,21,20)] = 1
# NA to 0
A.init[is.na(A.init)] = 0
# Return adjacency matrix
return(A.init)
}
# should we remove those that are not 0 or 1? not sure, maybe not.
# these values happend because of the weekly smoothing
# remove <- which(treat >0 & treat <1)
#
# treat <- treat[-remove]
# C <- C[-remove,]
# Y <- Y[-remove]
# feat <- feat[-remove,]
#
print(dim(feat))
dat_est <- build_X_K_multiple_C(feat=feat, treat=treat, C=C)
X_OLS1 <- dat_est$X_OLS1
X_OLS2 <- dat_est$X_OLS2
X_OLS3 <- dat_est$X_OLS3
X_OLS4 <- dat_est$X_OLS4
alpha_OLS1 <- tryCatch({alpha_hat <- solve(t(X_OLS1)%*%X_OLS1)%*%t(X_OLS1)%*%Y
alpha_hat},
error = function(e) NA)
colnames(alpha_OLS1) <- NULL
rownames(alpha_OLS1) <- NULL
beta_hat_1.OLS1 <- reparam_coefs(alpha_OLS1)$beta_hat_1
beta_hat_0.OLS1 <- reparam_coefs(alpha_OLS1)$beta_hat_0
est_OLS1<- c(omega_1[1:length( beta_hat_0.OLS1 )]%*%beta_hat_1.OLS1 +
omega_0[1:length( beta_hat_0.OLS1)]%*%beta_hat_0.OLS1)
var_OLS1.est <- sandwich.var.est(Z=X_OLS1, Y=Y, alpha.hat=alpha_OLS1,
omega_0=omega_0,
omega_1=omega_1, type="OLS1")
CI_OLS1 <- c(est_OLS1 - qnorm(1- 0.05/2)*sqrt(var_OLS1.est/(25*26)),
est_OLS1 + qnorm(1- 0.05/2)*sqrt(var_OLS1.est/(25*26)))
alpha_OLS1
var_OLS2.est <- sandwich.var.est(Z=X_OLS2, Y=Y, alpha.hat=alpha_OLS2,
omega_0=omega_0,
omega_1=omega_1)
alpha_OLS3 <- tryCatch({alpha_hat <- solve(t(X_OLS3)%*%X_OLS3)%*%t(X_OLS3)%*%Y
alpha_hat},
error = function(e) NA)
colnames(alpha_OLS3) <- NULL
rownames(alpha_OLS3) <- NULL
beta_hat_1.OLS3 <- reparam_coefs(alpha_OLS3)$beta_hat_1
beta_hat_0.OLS3 <- reparam_coefs(alpha_OLS3)$beta_hat_0
est_OLS3<- c(omega_1[1:length( beta_hat_0.OLS3 )]%*%beta_hat_1.OLS3 +
omega_0[1:length( beta_hat_0.OLS3)]%*%beta_hat_0.OLS3)
alpha_OLS2 <- tryCatch({alpha_hat <- solve(t(X_OLS2)%*%X_OLS2)%*%t(X_OLS2)%*%Y
alpha_hat},
error = function(e) NA)
colnames(alpha_OLS2) <- NULL
rownames(alpha_OLS2) <- NULL
beta_hat_1.OLS2 <- reparam_coefs(alpha_OLS2[1:2])$beta_hat_1
beta_hat_0.OLS2 <- reparam_coefs(alpha_OLS2[1:2])$beta_hat_0
est_OLS2 <- c(omega_1[1:length( beta_hat_0.OLS2 )]%*%beta_hat_1.OLS2 +
omega_0[1:length( beta_hat_0.OLS2)]%*%beta_hat_0.OLS2)
est_OLS2
est_OLS3
alpha_OLS2 <- tryCatch({alpha_hat <- solve(t(X_OLS2)%*%X_OLS2)%*%t(X_OLS2)%*%Y
alpha_hat},
error = function(e) NA)
alpha_OLS2
solve(t(X_OLS2)%*%X_OLS2)%*%t(X_OLS2)%*%Y
X_OLS2
C
C <- data[, -which(colnames(data) %in% c("Y","W"))]
C <- C[,-1]
C
C <- C[,adj]
C
alpha_OLS1 <- tryCatch({alpha_hat <- solve(t(X_OLS1)%*%X_OLS1)%*%t(X_OLS1)%*%Y
alpha_hat},
error = function(e) NA)
colnames(alpha_OLS1) <- NULL
rownames(alpha_OLS1) <- NULL
beta_hat_1.OLS1 <- reparam_coefs(alpha_OLS1)$beta_hat_1
beta_hat_0.OLS1 <- reparam_coefs(alpha_OLS1)$beta_hat_0
est_OLS1<- c(omega_1[1:length( beta_hat_0.OLS1 )]%*%beta_hat_1.OLS1 +
omega_0[1:length( beta_hat_0.OLS1)]%*%beta_hat_0.OLS1)
var_OLS1.est <- sandwich.var.est(Z=X_OLS1, Y=Y, alpha.hat=alpha_OLS1,
omega_0=omega_0,
omega_1=omega_1, adj)
est_OLS1
alpha_OLS2 <- tryCatch({alpha_hat <- solve(t(X_OLS2)%*%X_OLS2)%*%t(X_OLS2)%*%Y
alpha_hat},
error = function(e) NA)
colnames(alpha_OLS2) <- NULL
rownames(alpha_OLS2) <- NULL
beta_hat_1.OLS2 <- reparam_coefs(alpha_OLS2[1:2])$beta_hat_1
beta_hat_0.OLS2 <- reparam_coefs(alpha_OLS2[1:2])$beta_hat_0
est_OLS2 <- c(omega_1[1:length( beta_hat_0.OLS2 )]%*%beta_hat_1.OLS2 +
omega_0[1:length( beta_hat_0.OLS2)]%*%beta_hat_0.OLS2)
est_OLS2
dat_est <- build_X_K_multiple_C(feat=feat, treat=treat, C=C)
X_OLS1 <- dat_est$X_OLS1
X_OLS2 <- dat_est$X_OLS2
X_OLS3 <- dat_est$X_OLS3
X_OLS4 <- dat_est$X_OLS4
alpha_OLS2 <- tryCatch({alpha_hat <- solve(t(X_OLS2)%*%X_OLS2)%*%t(X_OLS2)%*%Y
alpha_hat},
error = function(e) NA)
colnames(alpha_OLS2) <- NULL
rownames(alpha_OLS2) <- NULL
beta_hat_1.OLS2 <- reparam_coefs(alpha_OLS2[1:2])$beta_hat_1
beta_hat_0.OLS2 <- reparam_coefs(alpha_OLS2[1:2])$beta_hat_0
est_OLS2 <- c(omega_1[1:length( beta_hat_0.OLS2 )]%*%beta_hat_1.OLS2 +
omega_0[1:length( beta_hat_0.OLS2)]%*%beta_hat_0.OLS2)
est_OLS2
alpha_OLS3 <- tryCatch({alpha_hat <- solve(t(X_OLS3)%*%X_OLS3)%*%t(X_OLS3)%*%Y
alpha_hat},
error = function(e) NA)
colnames(alpha_OLS3) <- NULL
rownames(alpha_OLS3) <- NULL
beta_hat_1.OLS3 <- reparam_coefs(alpha_OLS3)$beta_hat_1
beta_hat_0.OLS3 <- reparam_coefs(alpha_OLS3)$beta_hat_0
est_OLS3<- c(omega_1[1:length( beta_hat_0.OLS3 )]%*%beta_hat_1.OLS3 +
omega_0[1:length( beta_hat_0.OLS3)]%*%beta_hat_0.OLS3)
est_OLS3
library(dplyr)
library(Matrix)
library(gplots)
# Comments:
# data are smoothed weekly
# time period: start "2020-07-06", end "2020-10-18"
# have 15 weeks (X.oneweek) for each of the 26 cantons (X.Canton_3)
# new wording for response nach referee reports: "approximate weekly growth rate in supposed new infections"
# instead of "logarithm of the weekly growth rate of reported new cases"
setwd("~/GitHub/InvarianceCode")
data <- read.csv("RealData/data_case_prep.csv")
par(mfrow=c(1,1))
Results <- estimation.GATE.mask(data)
plotCI(x=Results[,1], li = Results[,2], ui =Results[,3] ,
col="black",lty=1,
#barcol="blue",
#labels=round(Results[,1],2),
xaxt="n", axes=FALSE, pch=19,
ylim=c(-0.8,0) , cex=0.9, sfrac=0.02,gap = 0.05,
ylab="", xlab="", main=paste0("Estimated GATE"))
axis(side=1, at=1:4, labels=c("OLS1", "OLS2", "OLS3", "OLS4"), cex=0.7)
axis(2, at=seq(-1,0, by=0.2),las=2, labels=seq(-1,0, by=0.2),
las = 2, cex.lab = 1.2,cex.axis = 1)
box(bty="l", col="black")
abline(a=0, b=0, lty=3, col="black")
abline(a=-0.1, b=0, lty=3,col="black")
abline(a=-0.2, b=0, lty=3,col="black")
abline(a=-0.3, b=0, lty=3,col="black")
abline(a=-0.4, b=0, lty=3,col="black")
abline(a=-0.5, b=0, lty=3,col="black")
abline(a=-0.6, b=0, lty=3,col="black")
abline(a=-0.7, b=0, lty=3,col="black")
abline(a=-0.8, b=0, lty=3,col="black")
estimation.GATE.mask <- function(data, nrweeks=15){
# adjacency matrix cantons
A <- create.A.init()
# A_large <- kronecker(diag(15),A)
A_large <- kronecker(diag(15),A)
treat <- data$W
C <- data[, -which(colnames(data) %in% c("Y","W"))]
Y <- data$Y
# adj <- c(1,8,9,10,12,13,14,15,20,21,22,23)
adj <-  c("X.casegrowthlag_we",
"X.percentage_age_we","X.Density_we","X.population_we",
"X.restGatherings_we","X.cancEvents_we","X.testingPolicy_we",
"X.workClosing2a_we","X.sre000d0_we","X.tre200d0_we","X.ure200d0_we",
"X.ferien_we")
############################# OLS1  ###########################################################
res_OLS1 <- estimator(1,0,treat,Y,C,c(),list(),A_large)
est_OLS1 <- res_OLS1$hat_tau
var_OLS1.est <-  res_OLS1$hat_var_tau
CI_OLS1 <- c(est_OLS1 - qnorm(1- 0.05/2)*sqrt(var_OLS1.est/(15*26)),
est_OLS1 + qnorm(1- 0.05/2)*sqrt(var_OLS1.est/(15*26)))
############################# OLS2 ###########################################################
res_OLS2 <- estimator(1,0,treat,Y,C,adj,list(),A_large)
est_OLS2 <- res_OLS2$hat_tau
var_OLS2.est <- res_OLS2$hat_var_tau
CI_OLS2 <- c(est_OLS2 - qnorm(1- 0.05/2)*sqrt(var_OLS2.est/(15*26)),
est_OLS2 + qnorm(1- 0.05/2)*sqrt(var_OLS2.est/(15*26)))
############################# OLS3 ###########################################################
res_OLS3 <- estimator(1,0,treat,Y,C,c(),list(feat_X1),A_large)
est_OLS3 <- res_OLS3$hat_tau
var_OLS3.est <- res_OLS3$hat_var_tau
CI_OLS3 <- c(est_OLS3 - qnorm(1- 0.05/2)*sqrt(var_OLS3.est/(15*26)),
est_OLS3 + qnorm(1- 0.05/2)*sqrt(var_OLS3.est/(15*26)))
############################# OLS4  ###########################################################
res_OLS4 <- estimator(1,0,treat,Y,C,adj,list(feat_X1),A_large)
est_OLS4 <- res_OLS4$hat_tau
var_OLS4.est <- res_OLS4$hat_var_tau
CI_OLS4 <- c(est_OLS4 - qnorm(1- 0.05/2)*sqrt(var_OLS4.est/(15*26)),
est_OLS4 + qnorm(1- 0.05/2)*sqrt(var_OLS4.est/(15*26)))
CIs <- rbind(CI_OLS1, CI_OLS2,CI_OLS3, CI_OLS4)
ests <-  rbind(est_OLS1, est_OLS2, est_OLS3, est_OLS4)
res <- cbind(ests, CIs)
return(res)
}
# adjacency matrix cantons
A <- create.A.init()
# A_large <- kronecker(diag(15),A)
A_large <- kronecker(diag(15),A)
feat_X1 <- function(A, treat){
A_tilde <- as.matrix(normalize_A(A))
feat <- c(A_tilde%*%treat)
feat[which(c(feat)=="NaN")] <- 0
return(feat)
}
normalize_A <- function(A){
weights <- 1/rowSums(A)
weights[which(weights=="Inf")] <- 0
weight_matrix <- matrix(rep(weights, dim(A)[1]), byrow=F, ncol=dim(A)[1])
A_norm <- A*weight_matrix
return(A_norm)
}
sandwich.var.est <- function(Z, Y, alpha.hat, omega_0, omega_1, adj){
eps.diag.mat <- diag(c(Y - Z%*%alpha.hat)^2)
n <- nrow(Z)
p <- ncol(Z)
bread <- 1/n*t(Z)%*%Z
meat <- 1/n*t(Z)%*%eps.diag.mat%*%Z
alpha.hat.var <- solve(bread)%*%meat%*%solve(bread)
var.coef.mat <- c(omega_0+omega_1,
omega_1,
rep(0, length(adj)))
var.est.tau <- as.numeric(t(var.coef.mat)%*%alpha.hat.var%*%var.coef.mat)
return(var.est.tau)}
reparam_coefs <- function(alpha_hat){
length_betas <- length(alpha_hat)/2
beta_hat_0 <- c(alpha_hat[1:length_betas])
beta_hat_1 <- c(alpha_hat[(length_betas+1):length(alpha_hat)])+c(alpha_hat[1:length_betas])
return(list(beta_hat_0=beta_hat_0, beta_hat_1=beta_hat_1))
}
create.A.init = function(){
# Output: adjacency matrix of swiss cantons with the same ordering as our data
# Names
cantons = c("GE", "VD", "FR", "NE", "VS", "BE", "JU", "SO", "BL", "BS", "AG",
"LU", "OW", "NW", "UR", "TI", "ZG", "SZ", "GL", "SG", "ZH", "SH",
"AR", "AI",  "GR", "TG")
# Initialize
A.init = matrix(NA, nrow = 26, ncol = 26)
colnames(A.init) = cantons
rownames(A.init) = cantons
# GE
A.init[1,2] = 1
# VD
A.init[2,c(1,4,3,5,6)] = 1
# FR
A.init[3, c(2,6, 4)] = 1
# NE
A.init[4, c(7,6,2,3)] = 1
# VS
A.init[5, c(2,6,15,16)] = 1
# BE
A.init[6,c(3,2,5,15,13,14,12,8,7,4)] = 1
# JU
A.init[7,c(9,10,8,6,4)] = 1
# SO
A.init[8,c(9,11,6,7)] = 1
# BL
A.init[9,c(8,11,10,7)] = 1
# BS
A.init[10,c(7,9)] = 1
# AG
A.init[11,c(9,8,12, 17,21)] = 1
# LU
A.init[12,c(11,17,18,14,13,6)] = 1
# OW
A.init[13,c(12,6,14)] = 1
# NW
A.init[14,c(15,13,12,18,6)] = 1
# UR
A.init[15, c(14,6,5,16,25,19,18)] = 1
# TI
A.init[16, c(5,15, 25)] = 1
# ZG
A.init[17, c(18,21,11,12)] = 1
# SZ
A.init[18,c(17,14,15,19,20,21,12)] = 1
# GL
A.init[19,c(18,15,25,20)] = 1
# SG
A.init[20, c(25,24,23,26,21,18,19)] = 1
# ZH
A.init[21,c(20,26,22,11,17,18)] = 1
# SH
A.init[22,c(21,26)] = 1
# AR
A.init[23, c(20,24)] = 1
# AI
A.init[24, c(20,23)] = 1
# GR
A.init[25,c(20,19,15,16)] = 1
# TG
A.init[26,c(22,21,20)] = 1
# NA to 0
A.init[is.na(A.init)] = 0
# Return adjacency matrix
return(A.init)
}
reparam_coefs <- function(alpha_hat){
length_betas <- length(alpha_hat)/2
beta_hat_0 <- c(alpha_hat[1:length_betas])
beta_hat_1 <- c(alpha_hat[(length_betas+1):length(alpha_hat)])+c(alpha_hat[1:length_betas])
return(list(beta_hat_0=beta_hat_0, beta_hat_1=beta_hat_1))
}
### function implementing the estimator proposed in "A Graphical Approach to Treatment Effect Estimation with Observational Network Data"
### Parameters
## W: treatment vector
## Y: outcome vector
## C: matrix of covariates
## adj: vector of indicators showing which covariates to adjust for
## features:  list of feature functions
## A: adjacency matrix for the network graph
## Y: outcome vector
## B: number of repetitions used to approximate the omega weights
## should be as high as possible but imposes large computational burden
### Returns
## hat_tau: estimate of target global treatment effect
## hat_var_tau: estimated variance of estimator for asy. valid CIs
setwd("~/GitHub/InvarianceCode")
source("helpers/helpers_estimator.R")
estimator <- function(pai, eta, W,Y,C,adj,feat_functions,A,B=100){
omega <- omega_comp(pai, eta, feat_functions,A,B)
X <- do.call(cbind,lapply(feat_functions, FUN = function(f){
f(A,W)}))
design <- cbind(1,X,W,W*X,as.matrix(C[,adj]))
alpha_full <- lm(Y~design-1)$coef
alpha <- alpha_full[1:(2+2*length(feat_functions))]
beta <- reparam_coefs(alpha)
estimate<- omega$omega_1%*%beta$beta_hat_1 +
omega$omega_0%*%beta$beta_hat_0
var_estimate <- sandwich.var.est(Z=design, Y=Y, alpha.hat=alpha_full,
omega_0=omega$omega_0,
omega_1=omega$omega_1, adj=adj)
return(list(hat_tau=estimate,hat_var_tau=var_estimate))
}
# adjacency matrix cantons
A <- create.A.init()
# A_large <- kronecker(diag(15),A)
A_large <- kronecker(diag(15),A)
A_large
A_large[,1]
A_large[1,]
# A_large <- kronecker(diag(15),A)
A_large <- kronecker(A,diag(15))
A_large
A_large[1,]
A_large[2,]
# adjacency matrix cantons
A <- create.A.init()
# A_large <- kronecker(diag(15),A)
A_large <- kronecker(A,diag(15))
treat <- data$W
C <- data[, -which(colnames(data) %in% c("Y","W"))]
Y <- data$Y
adj <-  c("X.casegrowthlag_we",
"X.percentage_age_we","X.Density_we","X.population_we",
"X.restGatherings_we","X.cancEvents_we","X.testingPolicy_we",
"X.workClosing2a_we","X.sre000d0_we","X.tre200d0_we","X.ure200d0_we",
"X.ferien_we")
res_OLS1 <- estimator(1,0,treat,Y,C,c(),list(),A_large)
est_OLS1 <- res_OLS1$hat_tau
var_OLS1.est <-  res_OLS1$hat_var_tau
CI_OLS1 <- c(est_OLS1 - qnorm(1- 0.05/2)*sqrt(var_OLS1.est/(15*26)),
est_OLS1 + qnorm(1- 0.05/2)*sqrt(var_OLS1.est/(15*26)))
res_OLS2 <- estimator(1,0,treat,Y,C,adj,list(),A_large)
est_OLS2 <- res_OLS2$hat_tau
var_OLS2.est <- res_OLS2$hat_var_tau
CI_OLS2 <- c(est_OLS2 - qnorm(1- 0.05/2)*sqrt(var_OLS2.est/(15*26)),
est_OLS2 + qnorm(1- 0.05/2)*sqrt(var_OLS2.est/(15*26)))
res_OLS3 <- estimator(1,0,treat,Y,C,c(),list(feat_X1),A_large)
est_OLS3 <- res_OLS3$hat_tau
var_OLS3.est <- res_OLS3$hat_var_tau
CI_OLS3 <- c(est_OLS3 - qnorm(1- 0.05/2)*sqrt(var_OLS3.est/(15*26)),
est_OLS3 + qnorm(1- 0.05/2)*sqrt(var_OLS3.est/(15*26)))
res_OLS4 <- estimator(1,0,treat,Y,C,adj,list(feat_X1),A_large)
est_OLS4 <- res_OLS4$hat_tau
var_OLS4.est <- res_OLS4$hat_var_tau
CI_OLS4 <- c(est_OLS4 - qnorm(1- 0.05/2)*sqrt(var_OLS4.est/(15*26)),
est_OLS4 + qnorm(1- 0.05/2)*sqrt(var_OLS4.est/(15*26)))
CIs <- rbind(CI_OLS1, CI_OLS2,CI_OLS3, CI_OLS4)
ests <-  rbind(est_OLS1, est_OLS2, est_OLS3, est_OLS4)
res <- cbind(ests, CIs)
res
es
est
ests
pai=1
eta=0
W=treat
adj
feature_functions <- list(feat_X1)
omega <- omega_comp(pai, eta, feat_functions,A,B)
feat_functions <- list(feat_X1)
omega <- omega_comp(pai, eta, feat_functions,A,B)
B <- 100
omega <- omega_comp(pai, eta, feat_functions,A,B)
omega
X <- do.call(cbind,lapply(feat_functions, FUN = function(f){
f(A,W)}))
X <- do.call(cbind,lapply(feat_functions, FUN = function(f){
f(A_large,W)}))
X
mean(X)
design <- cbind(1,X,W,W*X,as.matrix(C[,adj]))
design
alpha_full <- lm(Y~design-1)$coef
alpha <- alpha_full[1:(2+2*length(feat_functions))]
alpha
beta <- reparam_coefs(alpha)
beta
omega
alpha
estimate<- omega$omega_1%*%beta$beta_hat_1 +
omega$omega_0%*%beta$beta_hat_0
estimate
omega$omega_1%*%beta$beta_hat_1
omega$omega_0%*%beta$beta_hat_0
adj <- c()
omega <- omega_comp(pai, eta, feat_functions,A,B)
X <- do.call(cbind,lapply(feat_functions, FUN = function(f){
f(A,W)}))
design <- cbind(1,X,W,W*X,as.matrix(C[,adj]))
alpha_full <- lm(Y~design-1)$coef
alpha <- alpha_full[1:(2+2*length(feat_functions))]
alpha
omega
beta
alpha
alpha_full <- lm(Y~design-1)$coef
alpha <- alpha_full[1:(2+2*length(feat_functions))]
beta <- reparam_coefs(alpha)
beta
alpha
adj
adj <-  c("X.casegrowthlag_we",
"X.percentage_age_we","X.Density_we","X.population_we",
"X.restGatherings_we","X.cancEvents_we","X.testingPolicy_we",
"X.workClosing2a_we","X.sre000d0_we","X.tre200d0_we","X.ure200d0_we",
"X.ferien_we")
adj
omega
alpha
alpha_noadj <- alpha
adj <-  c("X.casegrowthlag_we",
"X.percentage_age_we","X.Density_we","X.population_we",
"X.restGatherings_we","X.cancEvents_we","X.testingPolicy_we",
"X.workClosing2a_we","X.sre000d0_we","X.tre200d0_we","X.ure200d0_we",
"X.ferien_we")
res_OLS1 <- estimator(1,0,treat,Y,C,c(),list(),A_large)
est_OLS1 <- res_OLS1$hat_tau
var_OLS1.est <-  res_OLS1$hat_var_tau
CI_OLS1 <- c(est_OLS1 - qnorm(1- 0.05/2)*sqrt(var_OLS1.est/(15*26)),
est_OLS1 + qnorm(1- 0.05/2)*sqrt(var_OLS1.est/(15*26)))
res_OLS2 <- estimator(1,0,treat,Y,C,adj,list(),A_large)
est_OLS2 <- res_OLS2$hat_tau
var_OLS2.est <- res_OLS2$hat_var_tau
CI_OLS2 <- c(est_OLS2 - qnorm(1- 0.05/2)*sqrt(var_OLS2.est/(15*26)),
est_OLS2 + qnorm(1- 0.05/2)*sqrt(var_OLS2.est/(15*26)))
res_OLS3 <- estimator(1,0,treat,Y,C,c(),list(feat_X1),A_large)
est_OLS3 <- res_OLS3$hat_tau
var_OLS3.est <- res_OLS3$hat_var_tau
CI_OLS3 <- c(est_OLS3 - qnorm(1- 0.05/2)*sqrt(var_OLS3.est/(15*26)),
est_OLS3 + qnorm(1- 0.05/2)*sqrt(var_OLS3.est/(15*26)))
omega <- omega_comp(pai, eta, feat_functions,A,B)
X <- do.call(cbind,lapply(feat_functions, FUN = function(f){
f(A,W)}))
X <- do.call(cbind,lapply(feat_functions, FUN = function(f){
f(A_large,W)}))
design <- cbind(1,X,W,W*X,as.matrix(C[,adj]))
alpha_full <- lm(Y~design-1)$coef
alpha <- alpha_full[1:(2+2*length(feat_functions))]
al[ha]
alpha
alpha_noadj
res
alpha_4 <- alpha
alpha 3 <- alpha_noadj
alpha_3 <- alpha_noadj
feat_functions <- list()
omega <- omega_comp(pai, eta, feat_functions,A,B)
X <- do.call(cbind,lapply(feat_functions, FUN = function(f){
f(A,W)}))
design <- cbind(1,X,W,W*X,as.matrix(C[,adj]))
alpha_full <- lm(Y~design-1)$coef
alpha <- alpha_full[1:(2+2*length(feat_functions))]
alpha
alpha_2 <- alpha
alpha_2
alpha_3
alpha_4
adj
ests
CIs
